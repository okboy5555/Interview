1、浏览器根据 DNS 服务器得到域名的 IP 地址

DNS查询：
在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 www.google.com
操作系统会首先在本地缓存中查询 IP
没有的话会去系统配置的 DNS 服务器中查询
如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
然后去该服务器查询 google 这个二级域名
接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
DNS 是基于 UDP 做的查询

2、TCP握手
TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后数据包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输

3、当 TCP 握手结束后就会进行 TLS 握手，然后就开始正式的传输数据
TLS握手过程：
服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）

客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书

服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

4、数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上
假设服务端会响应一个 HTML 文件
首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错

5、浏览器开始解析文件
如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件

6、文件解码成功后会正式开始渲染流程
先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行
如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕

7、CSSOM 树和 DOM 树构建完成后会开始生成 Render 树
在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上


相关问题：
为何要将 CSS 放在 HTML 头部？
这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。
为何要将 JS 放在 HTML 底部？
JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。


domContentLoaded 事件的触发
直截了当地结论是，DOMContentLoaded 事件在 html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发。
大家可以自己写一下测试代码，分别引用内联 js 和外链 js 进行测试。
load 事件的触发
当页面 DOM 结构中的 js、css、图片，以及 js 异步加载的 js、css 、图片都加载完成之后，才会触发 load 事件。


相关概念：

HTML文法的本质
上下文无关文法 就是这个文法中所有产生式的左边都是一个非终结符。
HTML 文法是 非上下文无关文法，例如一个 form 标签，如果它的父元素也是一个 form 标签，那么解析器会跳过它

解析算法
H5 规范详细地介绍了解析算法，这个算法分为两个阶段：
标记化
建树

对应的就是 词法分析 和 语法解析。

标记化算法
这个算法输入为 HTML文本，输出为 HTML标记。

运行逻辑大致为：
遇到 < ，状态修改为 标记打开
接收 [a-zA-Z] 的字符，会进入 标记名称状态，这个状态会一直保持，直到遇到 > ，表明标记名称记录完成，这是状态修改为 数据状态
接下来遇到 body 标签做同样的事情。此时，html 和 body 的标记都已经录好，进入 数据状态，之后保持这样的状态接收里面的字符
当再次遇到 < 的时候，回到 标记打开，一旦接收到下一个字符 / 时，这时候会创建一个 end tag 的 token，随后进入 标记名称状态，遇到 > 回到 数据状态

建树算法
DOM 树是一棵以 document 为根节点的多叉树。因此解析器首先会创建一个 document 对象，标记生成器会把每个标记的信息发送给 建树器，建树器在收到相应的标记时，会创建对应的 DOM 对象。创建这个 DOM 对象会做两件事情：
将 DOM 对象加入 DOM 树中
将对应标记压入存放开放元素的栈中

其他：
容错机制
HTML5 实现了非常强大的 宽容策略，容错能力非常强，在 WebKit 中，有如下经典容错示例：
使用 </br> 而不是 <br>
表格离散，会自动转换成同一个表格内
表单元素嵌套，会自动忽略里面的 form 元素





建立图层树

显式合成
下面是显式合成的情况：

拥有 层叠上下文 的节点。

层叠上下文也基本上是由一些特定的 CSS 属性创建的，一般有以下的情况：

HTML 根元素本身就具有层叠上下文属性
普通元素 position 不等于 static，并且设置了 z-index 属性，会产生层叠上下文
元素的 opacity 值不是1
元素的 transform 值不是 none
元素的 filter 值不是 none
元素的 isolation 值不是 isolate
will-change 指定的属性值为上面任意一个。
需要 裁剪 的地方

比如一个 div，你只个他设置了 100 * 100 的大小，而你在里面放置了很多内容，那么超出的文字部分就会被裁剪。如果你设置了滚动条，那么滚动条也会被单独提升为一个图层。

隐式合成
接下来就是隐式合成，简单来说就是 层叠等级低 的节点被提升为单独的图层之后那么 所有层叠等级比它高 的节点都会成为一个单独的图层。

这个隐式合成其实隐藏着一个巨大的风险，如果在一个大型应用中，当一个 z-index 比较低的元素被提升为一个单独的图层之后，层叠在它上面的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接上页面崩溃，这就是 层爆炸 的原理。

值得注意的是，当需要 重绘 的时候，只需要重绘本身，而不会影响到其他图层。




生成图块和生成位图

现在开始绘制操作，实际上渲染进程和绘制操作是由专门的线程来完成的，这个线程叫 合成线程。

绘制列表准备好了之后，渲染进程的主线程会给合成线程发送 commit 消息，把绘制列表提交给合成线程，接下来就是合成线程工作的时候。

首先，考虑到视口就这么大，当页面非常大的时候，需要滚动非常长的时间才能滚动到底部，如果一口气全部绘制出来是非常浪费性能的，因此合成线程首先要做的就是将图层分块。这些快的大小一般不会很大，这样可以大大加快页面的首屏展示。

因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使绘制一部分图块，也可能会浪费大量的时间。针对这一问题，Chrome 采用了一个策略：在首次合成图块是指采用一个 低分辨率 的图块，这样首次展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容合成完毕之后，再将低分辨率的图块进行替换，这也是 Chrome 首屏加载优化的手段之一。

顺便提醒一点，渲染进程中专门维护了一个 栅格化线程池，专门负责把 图块 转换为 位图数据。

然后合成线程会选择适口附近的图块，。把它交给栅格化线程池生成位图。

生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程



显示器显示内容
栅格化操作完成之后，合成线程会生成一个绘制命令，并发送给浏览器进程。

浏览器进程接收到这个命令后，根据这个命令把页面内容绘制到内存，也就是生成了一个页面，然后把这部分内存发送给显卡。

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60HZ，也就是一秒更新 60 张图片，一张图片停留的时间大约是 16.7ms，而每次更新图片都来自显卡的 前缓冲区，而显卡在接收到浏览器进程发送过来的页面后，会合成相应的图像，并将图像保存到 后缓冲区，然后系统自动将前缓冲区和后缓冲区进行对调，如此循环更新。